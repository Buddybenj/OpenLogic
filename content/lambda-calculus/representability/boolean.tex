% Part: lambda-calculus
% Chapter: representability
% Section: booleans

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lc}{rep}{bool}
\olsection{Boolean}

We can encode booleans in pure lambda calculus as follows:

\begin{align*}
  {true} &\eqs \lambd[x][\lambd[y][x]]\\
  {false} &\eqs \lambd[x][\lambd[y][y]]
\end{align*}

The intuition is that a boolean is a selector, in the sense that it is a function accepting two arguments
and returning either of them, depending on whether it represents true or
false. For example, $true ~ M ~ N$ always reduces to $M$, while $false
~ M ~ N$ always reduces to $N$.

\begin{explain}
  For those wondering why these two terms represent true and false:
  you may know that in electrical circuits a boolean is represented by
  a voltage: high for true and low for false. Then why can a voltage
  represent a boolean? Because assuming this, we can then design
  electrical components that can be interpreted in this way as conjuction or
  disjunction, etc. The boolean encoding is analogous as we will see.
\end{explain}


By this intuition we can further define some boolean functions. Here
are some of them:

\begin{align*}
  {and} &\eqs \lambd[a][\lambd[b][a ~ b ~ {false}]]
\end{align*}

The function ``and'' accepts two booleans as argument; knowing the
booleans will always behave as described above, it passes $b$ and ${false}$
to $a$, which will evaluated to $b$ if $a$ is ${true}$, or ${false}$ if $a$ is ${false}$,
which is exactly how conjuction is defined.

Note that we always assume the user is careful enough to pass only booleans to these functions; in the
case of being passed other terms, the result (normal form, if exists)
may be wierd and it is out of our scope.

\begin{prob}
  Try to define these functions on our boolean encoding:
  \begin{enumerate}
  \item Negation
  \item Disjunction
  \item Exclusive disjuction
  \end{enumerate}
\end{prob}
\end{document}