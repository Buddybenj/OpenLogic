% Part: lambda-calculus
% Chapter: representability
% Section: fixpoint

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lc}{rep}{fp}

\olsection{Fixpoint}

Now we're able to represent natural numbers, pairs and
lists by terms, we can do lots of fun stuff; for instance we can
define the factorial function:
\begin{align*}
  fac = \lambd[n][iszero ~ n ~ 0 ~ (mult ~ n (fac (pred ~ n)))]
\end{align*}
All the referenced functions are defined in previous sections.
Recall that $iszero n$ returns a boolean, which is a function
selecting between the two arguments based on the represented boolean.
Thus it will select $0$ if $iszero ~ n$ is yes, and $(mult ~ n (fac
(pred ~ n)))$ otherwise. This is exactly the definition we see on any
textbook.

However this definition is problematic: why can we use $fac$ in the
definition of $fac$? Note that recursive definition (self-reference)
is not part of lambda calculus. When we write definition of $true$,
$false$, numbers and functions, for example:
\begin{align*}
    {succ} &= \lambd[{n}][\lambd[fx][f ({n} f x)]]
\end{align*}
, what we really try to express is that successor is representable in
lambda calculus, and whenever we need to use successor in other
terms, we can just plug the right hand of the definition in the place
of the name $succ$. Do this recursively and finally in all definitions
no reference to other terms will exists. 

However this is not true in the case of self-reference; if we plug the
definition of $fac$ itself in the place of $fac$ in the right hand, we
get:
\begin{align*}
  fac = \lambd[n][iszero ~ n ~ 0 ~ (mult ~ n ((\lambd[n][iszero ~ n ~
  0 ~ (mult ~ n (fac (pred ~ n)))]) (pred ~ n)))]
\end{align*}
and we still haven't gotten rid of the reference. We can do this again
and again and the definition can keep growing. Thus this way of
defining factorial (or more generally self-reference functions) is not
feasible.

However, if someone could pass to us the function being defined, that
would be great. That is, we can define factorial as follows:
\begin{align*}
  fac' = \lambd[f][\lambd[n][iszero ~ n ~ 0 ~ (mult n (f (pred n)))]]
\end{align*}
and expect someone will pass the real factorial as parameter $f$ to $fac'$, then
the returning function is another factorial. Moreover, the factorial
being passed and the factorial being returns should be same.


That is, if we regard $fac'$ as a function accepting a function and
returning a function, then the fixpoint of $fac'$ would be the
factorial. So now we are looking for some technique to compute the
fixpoint of a term. And indeed there are some terms doing such things,
among which the best-known is the \emph{Y-combinator}, which is
defined as follows:
\begin{align*}
  Y &=  \lambd[f][(\lambd[x][f (x x)]) (\lambd[x][f (x x)])]
\end{align*}
, which has the fancy property that:
\begin{align*}
  Y g &= \lambd[f][(\lambd[x][f (x x)]) (\lambd[x][f (x x)])] g \\
      &= (\lambd[x][g (x x)]) (\lambd[x][g (x x)]) \\
      &= g ((\lambd[x][g (x x)]) (\lambd[x][g (x x)])) \\
      &= g (Y g)
\end{align*}
for any term $g$. We can extend this term as many times as we want,
and we will get:
\begin{align*}
    Y g &= g (Y g) \\
        &= g (g (Y g)) \\
        &\ldots \\
        &= g (g (\ldots ))
\end{align*}
Note how the last term is similar to fixed-point iteration, a method used to
compute the fixpoint of a real value function. Thus intuitively
speaking $g$ applied on any term for infinite times should be the
fixpoint of $g$. To get a concrete feeling, we can try out some terms;
take the factorial for instance:
\begin{align*}
  fac &= Y ~ fac'\\
  fac 3 &= Y ~ fac' ~ 3 \\
      &=fac' (Y ~ fac') 3 \\
      &=(\lambd[f][\lambd[n][iszero ~ n ~ 0 ~ (mult n (f (pred n)))]])
  fac ~ 3\\
      &= mult 3 (fac 2) \\
      \ldots
\end{align*}

\end{document}

